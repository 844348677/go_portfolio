Introducint Docker

Introducing Containers with Docker
the desire to simplify the process of building,shipping ,and running application

A container image is a lightweight, stand-alone, executable package of a piece of software that includes everything needed to run it:
code, runtime, system tools, system libraries , setting
Containers isolate software from its surroundings, for example, differences between development and staging
environments and help reduce conflicts between teams running different software on the same infrastructure

Containers have become the primary choice fro package microservices
Containers work by isolating processes and filesystems from each other

Installing Docker

Running our first container

think of it like types and instances ,
 a type defines fields and methods making up behavior
 an instance is a living instantiation of this type

 docker run --rm hello-world

 when you execute a docker run the first thing the engine does is check to see if you have the image isntalled locally
 if it doesn't then it connects to the default registry, to retrieve it

 the --rm flag tells the Docker engine to remove the container and delete any resources such as volumes it was using on exit

we will start a container and create a shell inside of it to show how you can navigate to the internal file system

docker run -it --rm alpine:latest sh
sudo docker run -it --rm alpine:latest sh

alpine is a lightweight version of linux and is perfect for running Go application.
the -it flags stand for interactive terminal it maps the standard in from your terminal to the input of the running container
the sh statement after the name of the image we want to run is the name of the command we would like to execute in the container when it start

if all want well , you should now be inside a shell of the container

ls

bin    etc    lib    mnt    root   sbin   sys    usr
dev    home   media  proc   run    srv    tmp    var
This is the root folder of the newly started container ,
container are immutable,
so any changes you make to the file system in a running container is disposed of when the container is stopped

Container are immutable instances of images, and the data volumes are by default non-persistent

docker ps

The docker ps command queries the engine and returns a list of the container,
by default this only shows the running container, if we add the -a flag we can alse see stopped containers

docker ps -a

jump back to the Apline Linux container , create a file in the root file system

touch mytestfile.txt

exit

docker ps

docker ps -a

"Container are immutable instance of images, and the data volumes are by default non-persistent"

there is something worth noting, however, unless you explicity remove a container it will persist in a stopped state on the Docker host

Removing containers is important to remember for two reasons
this first is that if you do not remember this,
you will fill up the disk on your host quickly as every time you create a container Docker will allocates space on the host fro the container volumes
the second is that the container can be restarted

restarted that sounds cool, in fact, it is a handy feature, not something you should use in your production environment,
for that you need to remember the golden rule and design your application accordingly

restart a stopped container

docker start -it [container_id] sh
这个命令现在不对了！！！
重启docker  再进入docker container
sudo docker restart   1861653d703c
sudo docker attach 1861653d703c

When running in a production environment , you cannot ensure that you can restart a container

docker rm container_id

if you want to remove all the stopped containers you can use the following command

docker rm -v $(docker ps -a -q)

the docker ps -a -q the -a flag will list all the containers including the stopped ones,
-q will return a list of the container IDs rather than the full details.
we are passing this as a parameter list to docker rm, whick will remove all the containers in the lsit

to avoid having to remove a container we can use the --rm flag when starting a new container.
this flag tell Docker to remove the container when it stops

Docker volumes
there are some instances when you may wish to write some files to a disk or when you want to read data from a disk such as in a development setup
Docker has the concept of voluemes , which can be mounted either from the host running the Docker machine or from another Docker container.

Union filesystem
the concept of a Union File System
The Union filesystem allows us to represent a logical file system by grouping different directories and or files together
it uses a Copy on Write technique,
which copies the layer when we modify the file system,
this way we only use about 1MB of space when creating a new image
when data is written to the file system   Docker copies th layer an puts it on the top of the stack

Mounting volumes
The -v , or --volume parameter allows you to specify a pair of values corresponding to the file system
you wish to mount on the host and the path where you would like to mount the volume inside the container

this time mounting a volume on the local file system

sudo docker run -it -v $(pwd):/host alpine:latest /bin/sh

if you change into thte host folder, you will see that there is access to the same folder from there you ran the docker run command

-v hostfolder:destinationfolder

this paths need to be absolute , and you cannot use a relative path like ./ or ../foldername
the volume you have just mounted has read/write access
any changes you make will be synchronized to the folder on the host so be careful to not go running

Docker ports
when running web application inside a container it is quite common that we will need to expose some ports to he outside world
By defualt, a Docker container is completely isolated,
and if you start a server running on port 8080 inside your container unless you explicitly specify that port is accessible from the outsied,
it will not be accessible

Mappint ports

cd /home/liuh/go/go_portfolio/building_microservices_with_go/src/ch01/basic_http_example
sudo docker run -it --rm -v $(pwd):/src -p 8080:8080 -w /src golang:alpine /bin/sh

Move to the folder where you checked out the sample code, and run the following Docker command: 上面

Unable to find image 'golang:alpine' locally
alpine: Pulling from library/golang

go run example.go

2018/07/27 14:14:17 server staring on port 8080

The -w flag : is to set the working directory
that means that any command we run in the container will be run inside this folder
When we start the shell , you will see that rather than having to change into the folder we specify in the second part of the volume mounting we are alreading in that folder
and can run our application
using a slightly different image this time
golang:alpine :
which is a version of Alpine with the most recent Go tools installed

curl -XPOST localhost:8080/helloworld

ch01 中的　json4　有完整的代码
cd /home/liuh/go/go_portfolio/building_microservices_with_go/src/ch01/r_w_json_4
curl -XPOST localhost:8080/helloworld -d '{"name":"Nic"}'

{"message":"Hello Nic"}

docker ps

-p
this takes a pair of values separated by a colon(:)
the first is the destination port on the host that we would like to bing to
the second is the source port on the Docker container to which our application is bound

you would not be able to start the program locally twice because of the port binding

we can do this one command by replacing the /bin/sh command with our go run command

sudo docker run -it --rm -v $(pwd):/src -p 8080:8080 -w /src golang:alpine go run json_4.go
curl -XPOST localhost:8080/helloworld -d '{"name":"Nic"}'

like volumes, you can specify multiple instances of the -p argument, which enables you to set up the bingding for multiple ports

Removing a container starting with an explicit name

Removing a container starting with an explicit name
Containers that start with a name parameter are not automatically removed even if you specify the -rm argument
if we append the -v option to the command , we can also remove the volumes that are associated with it

docker rm -v server

Docker networking
Docker networking is an interesting topic, and by default, Docker supports the following network modes:
bridge
host
none
orverly

Bridge networking
The bridge network is the default network that your container will connect ot when you launch them
this is how we were able to join our containers together in the last example
to facilitate this, Docker uses some of the core Linux capabilities such as networkding namespaces and virtual Ethernet interfaces(or veth interfaces)

When the Docker engine starts , it creates the docker0 virtual interface on the host machine
The docker0 interface is a virtual Ethernet bridge that automatically forwards packets between any other network interfaces that are attached to it.
when a container starts it creates a veth pair, it gives one to the container, which becomes its eth0, and the other connects to the docker0 bridge

http://172.17.0.1:8080/helloworld
http://192.168.1.104:8080/helloworld
http://127.0.0.1:8080/helloworld
都能访问

Host networking
the host network is essentially the same network that the Docker engine is running on.
when you connect a container to the host network all of the ports that are exposed by the container are automatically mapped to the hosts,
it alse shares the IP address of the host
while this may seem like a nice convenience , Docker was always designed to be capable of running multiple instances of the same container on the engine,
and since you can only bind a socket to one port in Linux using the host network limits this feature

the host network can also pose a security risk to your container as it is no longer protected by the principle of no trust
and you no longer have the ability to explicitly control if a port is exposed or not
that being said
due to the efficiencies of host networking it may in some instances be appropriate to connect a container to the host network if you anticipate that it is going to heavily use the network
就是预期有大量的使用网络，将container链接到host network ，因为　host networking 高效
An APi gateway might be on such example,
this container would still be possible to route request to other API containers that are sitting on the bridge network

No network
Removing your container from any network might in som instance be something you wish to do

Overlay network
The Docker overlay network is a unique Docker network that is used to connect containers running on seperate hosts to on another.
developing software one host all containers
production be running multiple hosts, each running multiple containers
the containers still need to talk to one another , and while we could route all traffic through
an ESB (enterprise service bus)
this is a little bit of an anti-pattern in the microservice world
it is in effect a network tunnel between machines which passes the traffic unmodified over th physical network
the problem with the overly is that you can no longer rely on Docker to update the etc/hosts file for you,
and you must depend on a dynamic service registry

Custom network drivers
Docker also supports plugins for networking ,
based around its open source libnetwork project
you can write custom networking plugin that can replace the networking subsystem of the Docker engine

Weaveworks

Project Calico

Creating custom bridge networks

To see the currently running networks on your docker engine, we can execute the following command

docker network ls

NETWORK ID          NAME                DRIVER              SCOPE
7f821b53187e        bridge              bridge              local
e15e0af7abc4        host                host                local
8a3854681d21        none                null                local

Creating a bridge network
T

