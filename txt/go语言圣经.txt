速通　中文版　go语言圣经
中文版的　就不看那么细了
增强概念
编程语言演化
ｐａｓｃａｌ
ＣＳＰ
ｉｏｔａ
defer

工具　go 命令先的字命令　run
原生支持　unicode
x+y
加好后可以换行　加号前不能换行
x+
y
for循环
空白标识符_
strings包中的ｊｏｉｎ函数
map k/v 
map的顺序
常量　必须　是　数字值　字符串　固定的ｂｏｏｌｅａｎ
[]color.Color{} 
gif.GIF{}
ioutil.Discard　输出流　不需要的数据

当一个goroutine 尝试在　一个channel 上ｓｅｎｄ或ｒｅｃｅｉｖｅs时　这个ｇｏｒｏｕｔｉｎｅ会阻塞在次
直到另一个ｇｏｒｏｕｔｉｎｅ往这个ｃｈａｎｎｅｌ里写入或者接收了值
没有指针运算
方法是和命名类型关联的一类函数
ｖａｒ　ｃｏｎｓｔ　ｆｕｎｃ　ｔｙｐｅ
接口　或引用类型　ｓｌｉｃｅ　ｍａｐ　ｃｈａｎ　和函数　对应的零值是nil
数据和结构体　聚合类型的零值　是每个元素字段对应类型的零值
in,err := os.Open(infile)
out,err := os.Create(outfile)
至少有一个新的变量
一个指针的值是另一个变量的地址
p != nil  测试为真　表示指向某个有效变量　　这个变量也许是零值
返回局部变量的地址
每次都是不一样的值
new  new(T) 创建一个ｔ类型的匿名变量　Ｔ类型的零值　返回变量地址
ｎｅｗ函数　语法糖
慎用　大小为０的类型
栈和堆
不是由　ｖａｒ和ｎｅｗ决定的
局部变量ｘ　从函数中逃逸了
自增　自减是语句　不是表达式　不能把它赋值给别人
元组赋值
赋值之前，先对右边的表达式进行求值　再统一更新左边变量的值
ｘ，ｙ　＝　ｙ，ｘ
x,y = x,x%y
x,y = x,x+y
map查找
类型断言
通道接收
v,ok = m[key]
v,ok = x.(T)
v,ok = <-ch
底层类型相同　也是不兼容的
运行时不会发送转换失败的错误　错误只会发生在编译阶段
不用类型　不能直接比较
r := [...]int{99: -1}
只有当两个数组的所有元素都是相等的时候数组才是相等的
