速通　中文版　go语言圣经
中文版的　就不看那么细了
增强概念
编程语言演化
ｐａｓｃａｌ
ＣＳＰ
ｉｏｔａ
defer

工具　go 命令先的字命令　run
原生支持　unicode
x+y
加好后可以换行　加号前不能换行
x+
y
for循环
空白标识符_
strings包中的ｊｏｉｎ函数
map k/v 
map的顺序
常量　必须　是　数字值　字符串　固定的ｂｏｏｌｅａｎ
[]color.Color{} 
gif.GIF{}
ioutil.Discard　输出流　不需要的数据

当一个goroutine 尝试在　一个channel 上ｓｅｎｄ或ｒｅｃｅｉｖｅs时　这个ｇｏｒｏｕｔｉｎｅ会阻塞在次
直到另一个ｇｏｒｏｕｔｉｎｅ往这个ｃｈａｎｎｅｌ里写入或者接收了值
没有指针运算
方法是和命名类型关联的一类函数
ｖａｒ　ｃｏｎｓｔ　ｆｕｎｃ　ｔｙｐｅ
接口　或引用类型　ｓｌｉｃｅ　ｍａｐ　ｃｈａｎ　和函数　对应的零值是nil
数据和结构体　聚合类型的零值　是每个元素字段对应类型的零值
in,err := os.Open(infile)
out,err := os.Create(outfile)
至少有一个新的变量
一个指针的值是另一个变量的地址
p != nil  测试为真　表示指向某个有效变量　　这个变量也许是零值
返回局部变量的地址
每次都是不一样的值
new  new(T) 创建一个ｔ类型的匿名变量　Ｔ类型的零值　返回变量地址
ｎｅｗ函数　语法糖
慎用　大小为０的类型
栈和堆
不是由　ｖａｒ和ｎｅｗ决定的
局部变量ｘ　从函数中逃逸了
自增　自减是语句　不是表达式　不能把它赋值给别人
元组赋值
赋值之前，先对右边的表达式进行求值　再统一更新左边变量的值
ｘ，ｙ　＝　ｙ，ｘ
x,y = x,x%y
x,y = x,x+y
map查找
类型断言
通道接收
v,ok = m[key]
v,ok = x.(T)
v,ok = <-ch
底层类型相同　也是不兼容的
运行时不会发送转换失败的错误　错误只会发生在编译阶段
不用类型　不能直接比较
r := [...]int{99: -1}
只有当两个数组的所有元素都是相等的时候数组才是相等的

多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠
操作超出cap(s)的上限将导致一个panic异常
超出len(s)则是意味着扩展了slice
底层都是共享之前的底层数组
函数传递slice将允许在函数内部修改底层数组的元素
不能使用==操作符来判断两个slice是否含有全部相等元素
slice唯一合法的比较操作是和nil比较
一个零值的slice等于nil。一个nil值的slice并没有底层数组
var s []int // len(s) == 0, s == nil
s = nil // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{} // len(s) == 0, s != nil
非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]
测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断
Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。
make([]T, len, cap)
[]rune("Hello, 世界")
slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型
type IntSlice struct {
	ptr *int
	len, cap int
}
x = append(x, 1)
x = append(x, 4, 5, 6)
是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作
map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效
向一个nil值的map存入元素将导致一个panic异常
第二个是一个布尔值，用于报告元素是否真的存

map中的key也是不相同的

结构体成员的输入顺序也有重要的意义
为S的结构体类型将不能再包含S类型的成员
S类型的结构体可以包含*S指针类型的成员

匿名成员
命名的类型或指向一个命名的类型的指针
匿名成员Circle和Point都有自己的名字——就是命名的类型名字
匿名类型的方法集

data, err := json.Marshal(movies)
个编码后的字节slice
Year int `json:"released"`

函数的类型被称为函数的标识符s

io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF
函数类型的零值是nil。调用值为nil的函数值会引起panic错误
var f func(int) int
如果不分成两部，函数字面量无法与visitAll绑定

values := []int{1, 2, 3, 4}
sum(values...)

5.8 defer
太多技巧
在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行

当panic异常发生时，程序会中断运行，并立即执行在该goroutine）中被延迟的函数（defer 机制

而一个方法则是一个一个和特殊类型关联的函
在能够给任意类型定义方法这一点上
方法可以被声明到任意类型，只要不是一个指针或者一个interface
对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名
如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的
编译器会隐式地帮我们用&p去调用ScaleBy这个方法
不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：

Nil也是一个合法的接收器类型
一个struct类型也可能会有多个匿名字段。
选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法
当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数"值"，这种函数会将其第一个参数用作接收器

Go的编码风格不禁止直接导出字段

Go语言中接口类型的独特之处在于它是满足隐式实现的
没有必要对于给定的具体类型定义所有满足的接口类型
(LSP里氏替换)
接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例
T类型的值不拥有所有*T指针的方法，那这样它就可能只实现更少的接口
我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法
接口值，由两个部分组成，一个具体的类型和那个类型的值
对于一个接口的零值就是它的类型和值的部分都是nil
两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等
如果两个接口值的动态类型相同，但是这个动态类型是不可比较的，将它们进行比较就会失败并且panic
一个包含nil指针的接口不是nil接口
给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。
它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true
*os.File的类型，nil是一个有效的接收者，但是*bytes.Buffer类型不在这些类型中

类型断言是一个使用在接口值上的操作
语法上它看起来像x.(T)被称为断言类型,这里x表示一个接口的类型和T表示一个类型

go f() // create a new goroutine that calls f(); don't wait
然而在我们使用go关键词的同时，需要慎重地考虑net.Conn中的方法在并发地调用时是否安全，事实上对于大多数类型来说也确实不安全
如果说goroutine是Go语音程序的并发体的话，那么channels它们之间的通信机制
它可以让一个goroutine通过它给另一个goroutine发送值信息
每个channel都有一个特殊的类型，也就是channels可发送数据的类型。
channel也一个对应make创建的底层数据结构的引用
复制一个channel或用于函数参数传递时,只是拷贝了一个channel引用,因此调用者何被调用者将引用同一个channel对象
。如果channel的容量大于零，那么该channel就是带缓存的channel
一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，
反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作
基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作
无缓存Channels有时候也被称为同步Channels
happens before，这是Go语言并发内存模型的一个关键术语
当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的
这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序
一个Channels的输出作为下一个Channels的输入,就是所谓的管道（pipeline）。
当一个channel被关闭后，再向该channel发送数据将导致panic异常。
当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值
使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环
Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。
任何双向channel向单向channel变量的赋值操作都将导致该隐式转换
如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG
和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。
无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的
像这种子问题都是完全彼此独立的问题被叫做易并行问题(译注：embarrassingly parallel
在每一个goroutine启动时加一，在goroutine退出时减
这种计数类型被称为sync.WaitGroup
Add是为计数器加一，必须在worker goroutine开始之前调用，而不是在goroutine中；
否则的话我们没办法确定Add是在"closer" goroutine调用Wait之前被调用。

如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。
因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到
Go语言并没有提供在一个goroutine中终止另一个goroutine的方法
的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播

当我们能够没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。
数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生
“不要使用共享数据来通信；使用通信来共享数据”
这种函数、互斥锁和变量的编排叫作监控monitor
defer调用只会比显式地调用Unlock成本高那么一点点，不过却在很大程度上保证了代码的整洁性
go里没有重入锁，关于重入锁的概念，请参考java
也就是说没法对一个已经锁上的mutex来再次上锁--这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去
“多读单写”锁(multiple readers, single writer lock)，Go语言提供的这样的锁是sync.RWMutex
懒初始化(lazy initialization)
构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！)
sync.Once
-race这个flag来运行程序，竞争检测器
这个例子说明我们无论可以用上锁，还是通信来建立并发程序都是可行的

每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量
一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB
一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量
但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩
OS线程会被操作系统内核调度
Go的运行时包含了其自己的调度器
每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数
比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine
Go调度器并不是用一个硬件定时器而是被Go语言"建筑"本身进行调度的
Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码
在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的
Goroutine没有ID号
thread-local storage(线程本地存储，多线程编程中不希望其它线程访问的内容
goroutine没有可以被程序员获取到的身份(id)的概念

非常多的Go语音开源包http://godoc.org

反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value.
