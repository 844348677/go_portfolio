速通　中文版　go语言圣经
中文版的　就不看那么细了
增强概念
编程语言演化
ｐａｓｃａｌ
ＣＳＰ
ｉｏｔａ
defer

工具　go 命令先的字命令　run
原生支持　unicode
x+y
加好后可以换行　加号前不能换行
x+
y
for循环
空白标识符_
strings包中的ｊｏｉｎ函数
map k/v 
map的顺序
常量　必须　是　数字值　字符串　固定的ｂｏｏｌｅａｎ
[]color.Color{} 
gif.GIF{}
ioutil.Discard　输出流　不需要的数据

当一个goroutine 尝试在　一个channel 上ｓｅｎｄ或ｒｅｃｅｉｖｅs时　这个ｇｏｒｏｕｔｉｎｅ会阻塞在次
直到另一个ｇｏｒｏｕｔｉｎｅ往这个ｃｈａｎｎｅｌ里写入或者接收了值
没有指针运算
方法是和命名类型关联的一类函数
ｖａｒ　ｃｏｎｓｔ　ｆｕｎｃ　ｔｙｐｅ
接口　或引用类型　ｓｌｉｃｅ　ｍａｐ　ｃｈａｎ　和函数　对应的零值是nil
数据和结构体　聚合类型的零值　是每个元素字段对应类型的零值
in,err := os.Open(infile)
out,err := os.Create(outfile)
至少有一个新的变量
一个指针的值是另一个变量的地址
p != nil  测试为真　表示指向某个有效变量　　这个变量也许是零值
返回局部变量的地址
每次都是不一样的值
new  new(T) 创建一个ｔ类型的匿名变量　Ｔ类型的零值　返回变量地址
ｎｅｗ函数　语法糖
慎用　大小为０的类型
栈和堆
不是由　ｖａｒ和ｎｅｗ决定的
局部变量ｘ　从函数中逃逸了
自增　自减是语句　不是表达式　不能把它赋值给别人
元组赋值
赋值之前，先对右边的表达式进行求值　再统一更新左边变量的值
ｘ，ｙ　＝　ｙ，ｘ
x,y = x,x%y
x,y = x,x+y
map查找
类型断言
通道接收
v,ok = m[key]
v,ok = x.(T)
v,ok = <-ch
底层类型相同　也是不兼容的
运行时不会发送转换失败的错误　错误只会发生在编译阶段
不用类型　不能直接比较
r := [...]int{99: -1}
只有当两个数组的所有元素都是相等的时候数组才是相等的

多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠
操作超出cap(s)的上限将导致一个panic异常
超出len(s)则是意味着扩展了slice
底层都是共享之前的底层数组
函数传递slice将允许在函数内部修改底层数组的元素
不能使用==操作符来判断两个slice是否含有全部相等元素
slice唯一合法的比较操作是和nil比较
一个零值的slice等于nil。一个nil值的slice并没有底层数组
var s []int // len(s) == 0, s == nil
s = nil // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{} // len(s) == 0, s != nil
非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]
测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断
Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。
make([]T, len, cap)
[]rune("Hello, 世界")
slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型
type IntSlice struct {
	ptr *int
	len, cap int
}
x = append(x, 1)
x = append(x, 4, 5, 6)
是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作
map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效
向一个nil值的map存入元素将导致一个panic异常
第二个是一个布尔值，用于报告元素是否真的存

map中的key也是不相同的

结构体成员的输入顺序也有重要的意义
为S的结构体类型将不能再包含S类型的成员
S类型的结构体可以包含*S指针类型的成员

匿名成员
命名的类型或指向一个命名的类型的指针
匿名成员Circle和Point都有自己的名字——就是命名的类型名字
匿名类型的方法集

data, err := json.Marshal(movies)
个编码后的字节slice
Year int `json:"released"`

函数的类型被称为函数的标识符s

io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF
函数类型的零值是nil。调用值为nil的函数值会引起panic错误
var f func(int) int
如果不分成两部，函数字面量无法与visitAll绑定

values := []int{1, 2, 3, 4}
sum(values...)

5.8 defer
太多技巧
在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行

当panic异常发生时，程序会中断运行，并立即执行在该goroutine）中被延迟的函数（defer 机制

而一个方法则是一个一个和特殊类型关联的函
在能够给任意类型定义方法这一点上
方法可以被声明到任意类型，只要不是一个指针或者一个interface
对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名
如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的
编译器会隐式地帮我们用&p去调用ScaleBy这个方法
不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：

Nil也是一个合法的接收器类型
一个struct类型也可能会有多个匿名字段。
选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法
当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数"值"，这种函数会将其第一个参数用作接收器

Go的编码风格不禁止直接导出字段
